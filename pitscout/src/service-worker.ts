/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.
import { clientsClaim } from 'workbox-core';
import { precacheAndRoute } from 'workbox-precaching';


declare const self: ServiceWorkerGlobalScope;
clientsClaim();

// Precache all the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
// TODO: Remove the Workbox plugin from webpack so this line can be removed
const manifest = self.__WB_MANIFEST;
precacheAndRoute(manifest);

// // Set up App Shell-style routing, so that all navigation requests
// // are fulfilled with your index.html shell. Learn more at
// // https://developers.google.com/web/fundamentals/architecture/app-shell
// const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
// registerRoute(
//	 // Return false to exempt requests from being fulfilled by index.html.
//	 ({ request, url }: { request: Request; url: URL }) => {
//		 // If this isn't a navigation, skip.
//		 if (request.mode !== 'navigate') {
//			 return false;
//		 }
//
//		 // If this is a URL that starts with /_, skip.
//		 if (url.pathname.startsWith('/_')) {
//			 return false;
//		 }
//
//		 // If this looks like a URL for a resource, because it contains
//		 // a file extension, skip.
//		 if (url.pathname.match(fileExtensionRegexp)) {
//			 return false;
//		 }
//
//		 // Return true to signal that we want to use the handler.
//		 return true;
//	 },
//	 createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
// );
//
// // An example runtime caching route for requests that aren't handled by the
// // precache, in this case same-origin .png requests like those from in public/
// registerRoute(
//	 // Add in any other file extensions or routing criteria as needed.
//	 ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
//	 // Customize this strategy as needed, e.g., by changing to CacheFirst.
//	 new StaleWhileRevalidate({
//		 cacheName: 'images',
//		 plugins: [
//			 // Ensure that once this runtime cache reaches a maximum size the
//			 // least-recently used images are removed.
//			 new ExpirationPlugin({ maxEntries: 50 }),
//		 ],
//	 })
// );

const addResourcesToCache = async (resources: string[]) => {
	const cache: Cache = await caches.open('v1');
	await cache.addAll(resources);
};

const images: string[] = [
	'/assets/NoData.svg',
	'/logos/32-favicon.png',
	'/logos/128-favicon.png',
	'/logos/192-pwa.png',
	'/logos/512-android-splash.png'
];
//
const webpage: string[] = [
	'/style.css',
	'/index.html'
];

self.addEventListener('install', (event) => {
	// event.waitUntil(addResourcesToCache([
	// 	...images,
	// 	'/style.css',
	// 	'/index.html'
	// ]));
	event.waitUntil(
		caches.open('v1')
			.then((cache: Cache) => cache.add('/manifest.json'))
	);
});

const putInCache = async (request, response): Promise<void> => {
	const cache: Cache = await caches.open('v1');
	await cache.put(request, response);
};

const networkFirst = async (request: Request): Promise<Response> => {
	try {
		const response: Response = await fetch(request);
		await putInCache(request, response);
		return response;
	} catch (reason: any) {
		console.error('Request failed with reason:', reason);

		const responseFromCache: Response = await caches.match(request);
		if (responseFromCache) {
			return responseFromCache;
		}

		throw reason;
	}
};

const cacheFirst = async (request: Request): Promise<Response> => {
	const responseFromCache: Response = await caches.match(request);
	if (responseFromCache) {
		return responseFromCache;
	}

	return fetch(request);
};

self.addEventListener('fetch', (event: FetchEvent) => {

	if (event.request.url.startsWith(`${process.env.REACT_APP_SERVER_URL}`)) {
		return;
	}

	event.respondWith(
		cacheFirst(event.request)
	);
});

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
	if (event.data && event.data.type === 'SKIP_WAITING') {
		self.skipWaiting();
	}
});
